<?xml version="1.0" encoding="UTF-8" ?>
<class name="Variant" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../class.xsd">
	<brief_description>
		The most fundamental data type in Godot.
	</brief_description>
	<description>
		In computer programming, a Variant class is designed to store a variety of other types. Dynamic programming languages like PHP, Lua, JavaScript, and GDScript tend to use them to store the data of variables on the backend. Variants allow properties to change their datatype freely.
		[codeblocks]
		[gdscript]
		var foo = 2 # foo is dynamically an integer.
		foo = "Now foo is a string!"
		foo = RefCounted.new() # foo is now an Object.
		var bar: int = 2 # bar is a statically typed integer.
		# bar = "Uh oh! I can't change the type of static variables!"
		[/gdscript]
		[csharp]
		// C# is statically typed. Once a variable has a type it cannot be changed.
		// You can use the `var` keyword to let the compiler infer the type automatically.
		var foo = 2; // Foo is a 32-bit integer (int).
		// foo = "foo was and will always be an integer. It cannot be turned into a string!";
		var boo = "boo is a string!";
		var ref = new RefCounted(); // var is especially useful when used together with a constructor.

		// Godot also provides a Variant type that works like a union of all the Variant-compatible types.
		Variant fooVar = 2; // fooVar is dynamically an integer (stored as a `long` in the Variant type).
		fooVar = "Now fooVar is a string!";
		fooVar = new RefCounted(); // fooVar is now a GodotObject.
		[/csharp]
		[/codeblocks]

		Godot tracks all scripting API variables within Variants. When a particular language enforces its own rules for keeping data typed, that language is applying its own custom logic over the base Variant scripting API:
		- GDScript automatically wraps values in them. It keeps all data in plain Variants by default and then optionally enforces custom static typing rules on variable types.
		- C# is statically typed, but uses its own implementation of Variant when it needs to represent a dynamic value. A [Variant] can be assigned any compatible type implicitly, but converting requires an explicit cast.

		A Variant in Godot takes up only 20 bytes and can store almost any datatype inside of it. Those can be roughly categorized as:
		- The [code]null[/code] type. It represents a Variant with no value assigned and is commonly returned by functions when a result cannot be found.
		- Atomic types, the most basic data types in Godot: [bool], [int], [float], [String]
		- Complex types, which consist of atomic types. They represent common constructs like vectors and colors, and allow you to easily work with them: [Color], [Vector2], [Transform3D], etc.
		- Container types, which can store multiple other Variants, including other containers: [Dictionary], [Array]. This also includes packed arrays, which are like an [Array] that can only hold one type of data and handle it very efficiently: [PackedColorArray], [PackedInt32Array], etc.
		- The [Object] type, inherited by every object in Godot, such as [Node], [Resource], [EditorFileSystemImportFormatSupportQuery], etc.
		- Miscellaneous types that don't belong in a specific category: [Callable], [Signal]
		This allows Variants to facilitate communication between all of Godot's systems. These systems are all made more accessible in Godot.

		You can check the specific type of a variant using [method @GlobalScope.typeof] with one of the [enum Variant.Type] constants.
		[codeblocks]
		[gdscript]
		var foo = 2
		match typeof(foo):
		    TYPE_NIL:
		        print("foo is null")
		    TYPE_INTEGER:
		        print("foo is an integer")
		    TYPE_OBJECT:
		        # Note that Objects are their own special category.
		        # To get the name of the underlying Object type, you need the `get_class()` method.
		        print("foo is a(n) %s" % foo.get_class()) # inject the class name into a formatted string.

		# In GDScript, you can also use the "is" keyword.
		if foo is int:
		    print("foo is an integer")
		[/gdscript]
		[csharp]
		Variant foo = 2;
		switch (foo.VariantType)
		{
		    case Variant.Type.Nil:
		        GD.Print("foo is null");
		        break;
		    case Variant.Type.Int:
		        GD.Print("foo is an integer");
		        break;
		    case Variant.Type.Object:
		        // Note that Objects are their own special category.
		        // You can convert a Variant to a GodotObject and use reflection to get its name.
		        GD.Print($"foo is a(n) {foo.AsGodotObject().GetType().Name}");
		        break;
		}
		[/csharp]
		[/codeblocks]
		To more easily convert the [enum Variant.Type] constant into a human-readable value, you can use [method @GlobalScope.type_string].

		Most Variants are passed by [b]value[/b]. When passed in a function, an independent copy is created that can't modify the original.
		[codeblock]
		func make_zero(number)
		    number = 0

		func _init():
		    var count = 6
		    make_zero(count)
		    print(count) # Prints 6
		[/codeblock]

		All container types and [Object]s are instead passed by [b]reference[/b]. When passed in a function, this function can modify the original.
		[codeblock]
		func remove_zero(array)
		    number.erase(0)

		func _init():
		    var my_array = [2, 5, 0, 8]
		    remove_zero(my_array)

		    print(my_array) # Prints [2, 5, 8]
		[/codeblock]
		To work around this, you need to create another instance of the container or object, for example with [method Array.duplicate].
	</description>
	<tutorials>
		<link title="Variant class introduction">$DOCS_URL/contributing/development/core_and_modules/variant_class.html</link>
	</tutorials>
</class>
